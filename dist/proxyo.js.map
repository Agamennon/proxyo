{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 24c65bb23d89820356d6","webpack:///./src/observer/observer.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\",\"umd\":\"react\"}","webpack:///./src/proxyo/connect.js","webpack:///./src/proxyo/provider.js","webpack:///./src/proxyo/proxyo.js","webpack:///./src/observer/builtIns/Map.js","webpack:///./src/observer/builtIns/Set.js","webpack:///./src/observer/builtIns/WeakMap.js","webpack:///./src/observer/builtIns/WeakSet.js","webpack:///./src/observer/builtIns/index.js","webpack:///./src/observer/nextTick.js","webpack:///./src/observer/wellKnownSymbols.js","webpack:///./src/proxyo/hoist-non-react-statics.js","webpack:///./src/proxyo/isShallow.js","webpack:///./src/proxyo/toClass.js","webpack:///./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG,qBAAqB;AACxB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC1RA,+C;;;;;;;;ACEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,qBAAqB;;AAE3D;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;;;;;;;;;;AChGA;;AAEA,0BAA0B;;;;AAI1B;;AAEA,2BAA2B;;AAE3B,8BAA8B,iDAAiD;;AAE/E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,YAAY;AACZ;;AAEA;;AAEA,yBAAyB;AACzB,8BAA8B;;AAE9B;;;;;;;;;;;ACpCA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACjBA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACxDA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACxDA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACtCA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC/BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;AChBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wB;;;;;;;AC3CA;AACA;AACA,QAAQ,uCAAuC;AAC/C,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C","file":"proxyo.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"proxyo\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"proxyo\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 24c65bb23d89820356d6","'use strict'\n\nconst nextTick = require('./nextTick')\nconst builtIns = require('./builtIns/index')\nconst wellKnowSymbols = require('./wellKnownSymbols')\n\nconst proxies = new WeakMap()\nconst observers = new WeakMap()\nconst queuedObservers = new Set()\n\nconst enumerate = Symbol('enumerate')\nlet queued = false\nlet currentObserver\nconst handlers = {get, ownKeys, set, deleteProperty}\n\n//gui\nvar interceptMap = new Map()\n//end gui\n\nmodule.exports = {\n  observe,\n  observable,\n  isObservable,\n  interceptMap\n}\n\nfunction observe (fn, context, ...args) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('First argument must be a function')\n  }\n  args = args.length ? args : undefined\n  const observer = {fn, context, args, observedKeys: [], exec, unobserve, unqueue}\n  runObserver(observer)\n  return observer\n}\n\nfunction exec () {\n  runObserver(this)\n}\n\nfunction unobserve () {\n  if (this.fn) {\n    this.observedKeys.forEach(unobserveKey, this)\n    this.fn = this.context = this.args = this.observedKeys = undefined\n    queuedObservers.delete(this)\n  }\n}\n\nfunction unqueue () {\n  queuedObservers.delete(this)\n}\n\nfunction observable (obj) {\n  obj = obj || {}\n  if (typeof obj !== 'object') {\n    throw new TypeError('first argument must be an object or undefined')\n  }\n  return proxies.get(obj) || toObservable(obj)\n\n}\n\nfunction toObservable (obj) {\n  let observable\n\n  const builtIn = builtIns.get(obj.constructor)//builtIns eh um mapa (get pega o valor com a chave obj.constructor)\n\n  //se o que for passado foi contruido com um contrutor do tipo function, como Map Set do proprio motor\n  if (typeof builtIn === 'function') {\n    observable = builtIn(obj, registerObserver, queueObservers)\n  } else if (!builtIn) { //quando builtin eh diferente de function e contem valor????\n    observable = new Proxy(obj, handlers)\n  } else {\n    observable = obj\n  }\n  proxies.set(obj, observable)\n  proxies.set(observable, observable)\n  observers.set(obj, new Map())\n  return observable\n}\n\nfunction isObservable (obj) {\n  if (typeof obj !== 'object') {\n    throw new TypeError('first argument must be an object')\n  }\n  return (proxies.get(obj) === obj)\n}\n\n\n\n\n\n\n\n\n\n\n/*\n\nfunction intercept(method, receiver ,key){\n  var interceptData = interceptMap.get(receiver);\n  var interceptResult;\n  if (interceptData){\n    if ((interceptData[0] === method) && (interceptData[1] === key || interceptData[1] === '')){\n      interceptResult = interceptData[2].apply(receiver,arguments)\n    }\n  }\n  return interceptResult\n}\n*/\n\n\n\n\nfunction get (target, key, receiver) {\n  if (key === '$raw') return target\n\n/*  console.log(\"proxyo get key- \",key)\n  console.log(\"proxyo get target- \",target)\n  console.log(\"proxyo get receiver- \",receiver)*/\n//INTERCEPT\n  var interceptData = interceptMap.get(receiver);\n  var interceptResult;\n  if (interceptData) {\n    if ((interceptData[0] === 'get') && (interceptData[1] === key || interceptData[1] === '')) {\n      interceptResult = interceptData[2].apply(receiver, arguments)\n    }\n  }\n\n  let result\n\n  if (interceptResult){\n    result = interceptResult;\n  }  else{\n    result = Reflect.get(target, key, receiver)\n  }\n//END INTERCEPT\n\n  if (typeof key === 'symbol' && wellKnowSymbols.has(key)) {\n    return result\n  }\n  const isObject = (typeof result === 'object' && result) //typeof object its object (arrays are condierd objects too) or null por isso check result\n\n let observable = isObject && proxies.get(result)\n\n  //another gui devolve observers sempre\n  if (!observable && isObject){\n    observable =  toObservable(result)\n  }\n //\n\n  if (currentObserver) {\n    registerObserver(target, key)\n    if (isObject) {\n      return observable || toObservable(result)\n    }\n  }\n\n  //gui additions  captura metodos e da autobind apply neles\n  if (typeof result == 'function' && result.name !== 'valueOf' && result.name !== 'toString' && result.name !== 'Object'){\n    var origMethod = target[key];\n    return function(...args){\n      const res = origMethod.apply(receiver,args);\n      return res\n    }\n  }\n//end gui\n  return observable || result\n\n}\n\n\nfunction set (target, key, value, receiver) {\n\n  //console.log('triggering Set at key',key)\n//  console.log('triggering Set at key',key)\n\n  var interceptData = interceptMap.get(receiver);\n  var interceptResult;\n  if (interceptData){\n    if ((interceptData[0] === 'set') && (interceptData[1] === key || interceptData[1] === '')){\n      interceptResult = interceptData[2].apply(receiver,arguments)\n    }\n  }\n\n\n    //value = interceptResult\n    //console.log('interceptResult',interceptResult)\n    //value = interceptResult\n    if (key === 'length' || value !== Reflect.get(target, key, receiver)) {\n      queueObservers(target, key)\n      queueObservers(target, enumerate)\n    }\n    if (typeof value === 'object' && value) {\n      value = value.$raw || value\n    }\n    //return Reflect.set(target, key, value, receiver)\n    //mudanca grava tudo como observer\n   // return target[key] = value\n   // return Reflect.set(target, key, (typeof value === 'object' && value) ? toObservable(value): value, receiver)\n    return Reflect.set(target, key, value, receiver)\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction registerObserver (target, key) {\n  if (currentObserver) {\n    const observersForTarget = observers.get(target)\n    let observersForKey = observersForTarget.get(key)\n    if (!observersForKey) {\n      observersForKey = new Set()\n      observersForTarget.set(key, observersForKey)\n    }\n    if (!observersForKey.has(currentObserver)) {\n      observersForKey.add(currentObserver)\n      currentObserver.observedKeys.push(observersForKey)\n    }\n  }\n}\n\nfunction ownKeys (target) {\n  registerObserver(target, enumerate)\n  return Reflect.ownKeys(target)\n}\n\n\nfunction deleteProperty (target, key) {\n  if (Reflect.has(target, key)) {\n    queueObservers(target, key)\n    queueObservers(target, enumerate)\n  }\n  return Reflect.deleteProperty(target, key)\n}\n\nfunction queueObservers (target, key) {\n  const observersForKey = observers.get(target).get(key)\n  if (observersForKey && observersForKey.constructor === Set) {\n    observersForKey.forEach(queueObserver)\n  } else if (observersForKey) {\n    queueObserver(observersForKey)\n  }\n}\n\nfunction queueObserver (observer) {\n  if (!queued) {\n    nextTick(runObservers)\n    queued = true\n  }\n  queuedObservers.add(observer)\n}\n\nfunction runObservers () {\n  queuedObservers.forEach(runObserver)\n  queuedObservers.clear()\n  queued = false\n}\n\nfunction runObserver (observer) {\n  try {\n    currentObserver = observer\n    observer.fn.apply(observer.context, observer.args)\n  } finally {\n    currentObserver = undefined\n  }\n}\n\nfunction unobserveKey (observersForKey) {\n  observersForKey.delete(this)\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/observer.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\",\"umd\":\"react\"}\n// module id = 1\n// module chunks = 0","\n\nvar React = require ('react')\nvar observer = require('../observer/observer')\nvar isObjectShallowModified = require ('./isShallow');\nvar toClass = require ('./toClass');\nvar hoistStatics = require('./hoist-non-react-statics');\n\nvar connect = (Comp,obs) => {\n//https://github.com/mobxjs/mobx-react/blob/master/src/inject.js\n  Comp = toClass(Comp);\n\n  class Enhancer extends Comp {\n\n   /* static contextTypes = {\n      proxyoStores: React.PropTypes.object\n    };*/\n\n    constructor(props,context){\n\n    //  console.log('constructor');\n      super(...arguments);\n    //  console.log(context);\n      this._fn = this._fn.bind(this);\n      this._signal = null;\n      this._mounted = false;\n      this._renderResult = null;\n    }\n\n    _fn (){\n      this._renderResult = super.render()\n      if (this._mounted){\n        this.forceUpdate()\n      }\n    }\n\n    componentDidMount() {\n     // console.log('did mount')\n      this._mounted = true;\n      if (super.componentWillUnmount){\n        super.componentWillUnmount()\n      }\n    }\n\n     shouldComponentUpdate(nextProps,nextState) {\n      //return false\n      delete this.props.store\n    //  console.log(this.props)\n    //  console.log(nextProps)\n    //  console.log(isObjectShallowModified(this.props, nextProps));\n      if (this.state !== nextState) {\n         return true;\n       }\n      return isObjectShallowModified(this.props, nextProps);\n\n     }\n\n    componentWillUnmount() {\n   //   console.log('willunmount')\n      if (super.componentWillUnmount){\n        super.componentWillUnmount()\n      }\n      this._mounted = false\n      if (this._signal) {\n        this._signal.unobserve();\n        //  console.log(\"signal released\")\n      }\n    }\n    render() {\n     this.props =  Object.assign({}, this.props, {store:obs})\n//     console.log('render called ->', Comp.name)\n     if (!this._mounted){\n        this._signal = observer.observe(this._fn,this);\n      }\n     return this._renderResult\n    }\n  };\n\n  function getDisplayName (Comp) {\n    return Comp.displayName ||\n        Comp.name || `Component`\n  }\n\n  Enhancer.displayName = `HOCProxyo(${getDisplayName(Comp)})`\n\n  Enhancer.contextTypes = {\n    proxyoStores: React.PropTypes.object\n  };\n\n  hoistStatics(Enhancer,Comp)\n\n  return Enhancer\n}\n\n\n\nmodule.exports = connect\n//export default connect2\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/connect.js\n// module id = 2\n// module chunks = 0","\nvar React = require('react')\n\nconst specialReactKeys = {children: true, key: true, ref: true};\n\n\n\nclass Provider extends React.Component {\n\n/*  static contextTypes = {proxyoStores: React.PropTypes.object};\n\n  static childContextTypes = {proxyoStores: React.PropTypes.object.isRequired};*/\n\n  render() {\n    return React.Children.only(this.props.children);\n  }\n\n  getChildContext() {\n  //  console.log(this.props);\n   // const stores = {};\n    // inherit stores\n /*   const baseStores = this.context.proxyoStores;\n    if (baseStores)\n      for (let key in baseStores) {\n        stores[key] = baseStores[key];\n      }\n    // add own stores\n    for (let key in this.props)\n      stores[key] = this.props[key];\n    console.log(stores);*/\n    return {proxyoStores: this.props.proxyoStores};\n  }\n\n}\n\nProvider.contextTypes = {proxyoStores: React.PropTypes.object};\nProvider.childContextTypes = {proxyoStores: React.PropTypes.object.isRequired};\n\nmodule.exports = Provider\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/provider.js\n// module id = 3\n// module chunks = 0","\n\nvar observable = require('../observer/observer').observable\nvar interceptMap = require('../observer/observer').interceptMap\n\n\nvar intercept = function(target,method,property,interceptor){\n  interceptMap.set(target,[method,property,interceptor])\n}\n\nvar State = function(state){\n  return observable(state);\n}\n\nmodule.exports = {\n  intercept,\n  State\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/proxyo.js\n// module id = 4\n// module chunks = 0","'use strict'\n\nconst native = Map.prototype\nconst masterKey = Symbol('Map master key')\n\nconst getters = ['has', 'get']\nconst iterators = ['forEach', 'keys', 'values', 'entries', Symbol.iterator]\nconst all = ['set', 'delete', 'clear'].concat(getters, iterators)\n\nmodule.exports = function shim (target, registerObserver, queueObservers) {\n  target.$raw = {}\n\n  for (let method of all) {\n    target.$raw[method] = function () {\n      native[method].apply(target, arguments)\n    }\n  }\n\n  for (let getter of getters) {\n    target[getter] = function (key) {\n      registerObserver(this, key)\n      return native[getter].apply(this, arguments)\n    }\n  }\n\n  for (let iterator of iterators) {\n    target[iterator] = function () {\n      registerObserver(this, masterKey)\n      return native[iterator].apply(this, arguments)\n    }\n  }\n\n  target.set = function (key, value) {\n    if (this.get(key) !== value) {\n      queueObservers(this, key)\n      queueObservers(this, masterKey)\n    }\n    return native.set.apply(this, arguments)\n  }\n\n  target.delete = function (key) {\n    if (this.has(key)) {\n      queueObservers(this, key)\n      queueObservers(this, masterKey)\n    }\n    return native.delete.apply(this, arguments)\n  }\n\n  target.clear = function () {\n    if (this.size) {\n      queueObservers(this, masterKey)\n    }\n    return native.clear.apply(this, arguments)\n  }\n\n  return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/Map.js\n// module id = 5\n// module chunks = 0","'use strict'\n\nconst native = Set.prototype\nconst masterValue = Symbol('Set master value')\n\nconst getters = ['has']\nconst iterators = ['forEach', 'keys', 'values', 'entries', Symbol.iterator]\nconst all = ['add', 'delete', 'clear'].concat(getters, iterators)\n\nmodule.exports = function shim (target, registerObserver, queueObservers) {\n  target.$raw = {}\n\n  for (let method of all) {\n    target.$raw[method] = function () {\n      native[method].apply(target, arguments)\n    }\n  }\n\n  for (let getter of getters) {\n    target[getter] = function (value) {\n      registerObserver(this, value)\n      return native[getter].apply(this, arguments)\n    }\n  }\n\n  for (let iterator of iterators) {\n    target[iterator] = function () {\n      registerObserver(this, masterValue)\n      return native[iterator].apply(this, arguments)\n    }\n  }\n\n  target.add = function (value) {\n    if (!this.has(value)) {\n      queueObservers(this, value)\n      queueObservers(this, masterValue)\n    }\n    return native.add.apply(this, arguments)\n  }\n\n  target.delete = function (value) {\n    if (this.has(value)) {\n      queueObservers(this, value)\n      queueObservers(this, masterValue)\n    }\n    return native.delete.apply(this, arguments)\n  }\n\n  target.clear = function () {\n    if (this.size) {\n      queueObservers(this, masterValue)\n    }\n    return native.clear.apply(this, arguments)\n  }\n\n  return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/Set.js\n// module id = 6\n// module chunks = 0","'use strict'\n\nconst native = WeakMap.prototype\n\nconst getters = ['has', 'get']\nconst all = ['set', 'delete'].concat(getters)\n\nmodule.exports = function shim (target, registerObserver, queueObservers) {\n  target.$raw = {}\n\n  for (let method of all) {\n    target.$raw[method] = function () {\n      native[method].apply(target, arguments)\n    }\n  }\n\n  for (let getter of getters) {\n    target[getter] = function (key) {\n      registerObserver(this, key)\n      return native[getter].apply(this, arguments)\n    }\n  }\n\n  target.set = function (key, value) {\n    if (this.get(key) !== value) {\n      queueObservers(this, key)\n    }\n    return native.set.apply(this, arguments)\n  }\n\n  target.delete = function (key) {\n    if (this.has(key)) {\n      queueObservers(this, key)\n    }\n    return native.delete.apply(this, arguments)\n  }\n\n  return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/WeakMap.js\n// module id = 7\n// module chunks = 0","'use strict'\n\nconst native = WeakSet.prototype\n\nconst getters = ['has']\nconst all = ['add', 'delete'].concat(getters)\n\nmodule.exports = function shim (target, registerObserver, queueObservers) {\n  target.$raw = {}\n\n  for (let method of all) {\n    target.$raw[method] = function () {\n      native[method].apply(target, arguments)\n    }\n  }\n\n  for (let getter of getters) {\n    target[getter] = function (value) {\n      registerObserver(this, value)\n      return native[getter].apply(this, arguments)\n    }\n  }\n\n  target.add = function (value) {\n    if (!this.has(value)) {\n      queueObservers(this, value)\n    }\n    return native.add.apply(this, arguments)\n  }\n\n  target.delete = function (value) {\n    if (this.has(value)) {\n      queueObservers(this, value)\n    }\n    return native.delete.apply(this, arguments)\n  }\n\n  return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/WeakSet.js\n// module id = 8\n// module chunks = 0","'use strict'\n\nconst MapShim = require('./Map')\nconst SetShim = require('./Set')\nconst WeakMapShim = require('./WeakMap')\nconst WeakSetShim = require('./WeakSet')\n\n\nmodule.exports = new Map([\n  [Map, MapShim],\n  [Set, SetShim],\n  [WeakMap, WeakMapShim],\n  [WeakSet, WeakSetShim],\n  [Date, true],\n  [RegExp, true]\n])\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/index.js\n// module id = 9\n// module chunks = 0","'use strict'\n//https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\nlet promise = Promise.resolve()\nlet mutateWithTask\nlet currTask\n\nmodule.exports = function nextTick (task) {\n  currTask = task\n  if (mutateWithTask) {\n    mutateWithTask()\n  } else {\n    promise = promise.then(task)\n  }\n}\n\nif (typeof MutationObserver !== 'undefined') {\n  let counter = 0\n  const observer = new MutationObserver(onTask)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {characterData: true})\n\n  mutateWithTask = function mutateWithTask () {\n    counter = (counter + 1) % 2\n    textNode.textContent = counter\n  }\n}\n\nfunction onTask () {\n  if (currTask) {\n    currTask()\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/nextTick.js\n// module id = 10\n// module chunks = 0","'use strict'\n\nconst wellKnowSymbols = new Set()\n\nfor (let key of Object.getOwnPropertyNames(Symbol)) {\n  const value = Symbol[key]\n  if (typeof value === 'symbol') {\n    wellKnowSymbols.add(value)\n  }\n}\n\nmodule.exports = wellKnowSymbols\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/wellKnownSymbols.js\n// module id = 11\n// module chunks = 0","var REACT_STATICS = {\n  childContextTypes: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\n\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  arguments: true,\n  arity: true\n};\n\nvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\nmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n  if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n    var keys = Object.getOwnPropertyNames(sourceComponent);\n\n    /* istanbul ignore else */\n    if (isGetOwnPropertySymbolsAvailable) {\n      keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n    }\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n        try {\n          targetComponent[keys[i]] = sourceComponent[keys[i]];\n        } catch (error) {\n\n        }\n      }\n    }\n  }\n\n  return targetComponent;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/hoist-non-react-statics.js\n// module id = 12\n// module chunks = 0","function isObjectShallowModified(prev, next) {\n  if (null == prev || null == next || typeof prev !== \"object\" || typeof next !== \"object\") {\n    return prev !== next;\n  }\n  const keys = Object.keys(prev);\n  if (keys.length !== Object.keys(next).length) {\n    return true;\n  }\n  let key;\n  for (let i = keys.length - 1; i >= 0, key = keys[i]; i--) {\n    if (next[key] !== prev[key]) {\n      return true;\n    }\n  }\n  return false;\n}\nmodule.exports = isObjectShallowModified\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/isShallow.js\n// module id = 13\n// module chunks = 0","var React = require('react')\n\nconst getDisplayName = Component => {\n  if (typeof Component === 'string') {\n    return Component\n  }\n\n  if (!Component) {\n    return undefined\n  }\n\n  return Component.displayName || Component.name || 'Component'\n}\n\nconst isClassComponent = Component => Boolean(\n    Component &&\n    Component.prototype &&\n    typeof Component.prototype.isReactComponent === 'object'\n)\n\n\n\nconst toClass = baseComponent => {\n  if (isClassComponent(baseComponent)) {\n    return baseComponent\n  }\n\n  class ToClass extends React.Component {\n    render() {\n      if (typeof baseComponent === 'string') {\n        return React.createElement(baseComponent, this.props)\n      }\n      return baseComponent(this.props, this.context)\n    }\n  }\n\n  ToClass.displayName = getDisplayName(baseComponent)\n  ToClass.propTypes = baseComponent.propTypes\n  ToClass.contextTypes = baseComponent.contextTypes\n  ToClass.defaultProps = baseComponent.defaultProps\n\n  return ToClass\n}\n\nmodule.exports = toClass\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/toClass.js\n// module id = 14\n// module chunks = 0","\n/*\nimport observer from './observer/observer'\nimport {CreateState,globalState, globalActions}  from './proxyo/createState'\nexport {CreateState,globalState,\n  globalActions,observer}\n*/\nvar observer = require('./observer/observer');\nvar proxyo = require('./proxyo/proxyo');\n\nmodule.exports = {\n  observe:observer.observe,\n  observable:observer.observable,\n  isObservable:observer.isObservable,\n  observer:observer,\n  State:proxyo.State,\n  intercept:proxyo.intercept,\n  connect: require('./proxyo/connect'),\n  Provider: require('./proxyo/provider'),\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 15\n// module chunks = 0"],"sourceRoot":""}
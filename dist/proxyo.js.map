{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 611413f09ae07e0f08c5","webpack:///./src/observer/observerLight.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\",\"umd\":\"react\"}","webpack:///./src/proxyo/connect.js","webpack:///./src/proxyo/provider.js","webpack:///./src/proxyo/proxyo.js","webpack:///./src/observer/builtIns/Map.js","webpack:///./src/observer/builtIns/Set.js","webpack:///./src/observer/builtIns/WeakMap.js","webpack:///./src/observer/builtIns/WeakSet.js","webpack:///./src/observer/builtIns/index.js","webpack:///./src/observer/nextTick.js","webpack:///./src/observer/wellKnownSymbols.js","webpack:///./src/proxyo/hoist-non-react-statics.js","webpack:///./src/proxyo/isShallow.js","webpack:///./src/proxyo/toClass.js","webpack:///./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,qBAAqB;AACxB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;;AAEA,4DAA4D;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;;AAEA;AACA,yEAAyE;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA,KAAK;AACL;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;;AAEA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClOA,+C;;;;;;;;ACEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;AAIA,wCAAwC,eAAe,UAAU;AACjE;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC;AACzC;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,qBAAqB;;AAE7D;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;;;AAIA;AACA;;;;;;;;;;;ACzKA;;AAEA,0BAA0B;;;;AAI1B;;AAEA,2BAA2B;;AAE3B,8BAA8B,iDAAiD;;AAE/E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,YAAY;AACZ;;AAEA;;AAEA,yBAAyB;AACzB,8BAA8B;;AAE9B;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI;;AAEJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5IA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACxDA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACxDA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACtCA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC/BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;AChBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wB;;;;;;;AC3CA;AACA;AACA,QAAQ,uCAAuC;AAC/C,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"proxyo.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"proxyo\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"proxyo\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 611413f09ae07e0f08c5","'use strict'\n\nconst nextTick = require('./nextTick')\nconst builtIns = require('./builtIns/index')\nconst wellKnowSymbols = require('./wellKnownSymbols')\n\nconst proxies = new WeakMap()\nconst observers = new WeakMap()\nconst queuedObservers = new Set()\nconst imediateObservers = new Set()\nconst enumerate = Symbol('enumerate')\n\n\nlet queued = false\nlet currentObserver\n\nconst handlers = {get, set, ownKeys, deleteProperty}\n\nmodule.exports = {\n  proxies,\n  observe,\n  observable,\n  isObservable,\n}\n\n\nfunction observe (fn, context, ...args) {\n\n  if (typeof fn !== 'function') {\n    throw new TypeError('First argument must be a function')\n  }\n // console.log('-------------------------------------------------------IMEDIATE',imediate)\n  args = args.length ? args : undefined\n  const observer = {fn, context, args, observedKeys: [],unobserve}\n  runObserver(observer,true)\n  return observer\n}\n\n\nfunction observable (obj) {\n  obj = obj || {}\n  if (typeof obj !== 'object') {\n    throw new TypeError('first argument must be an object or undefined')\n  }\n  return proxies.get(obj) || toObservable(obj)\n\n}\n\nfunction toObservable (obj) {\n /* let observable\n  const builtIn = builtIns.get(obj.constructor)//builtIns eh um mapa (get pega o valor com a chave obj.constructor)\n  if (typeof builtIn === 'function') {\n    console.log('BINGO BINGO BINGO')\n    observable = builtIn(obj, registerObserver, queueObserver)\n  } else if (!builtIn) { //quando builtin eh diferente de function e contem valor????\n    observable = new Proxy(obj, handlers)\n  } else {\n    observable = obj\n  }\n  proxies.set(obj, observable)\n  proxies.set(observable, observable)\n  observers.set(obj, new Map())\n  return observable*/\n\n  let observable\n  observable = new Proxy(obj, handlers)\n  proxies.set(obj, observable)\n  proxies.set(observable, observable)\n  observers.set(obj, new Map())\n  return observable\n}\n\nfunction isObservable (obj) {\n  if (typeof obj !== 'object') {\n    throw new TypeError('first argument must be an object')\n  }\n  return (proxies.get(obj) === obj)\n}\n\n\n\nfunction get (target, key, receiver) {\n  if (key === '$raw') return target\n\n  var result = Reflect.get(target, key, receiver)\n  console.log('getting', key, target)\n\n  if (typeof key === 'symbol' && wellKnowSymbols.has(key)) {   //NOT OBSERVE WELL KNOWN SIMBOLS\n    return result\n  }\n\n  const isObject = (typeof result === 'object' && result) //typeof object its object (arrays are condierd objects too) or null por isso check result\n  let observable = isObject && proxies.get(result)\n\n  if (!observable && isObject){\n    observable =  toObservable(result)\n  }\n\n  if (currentObserver) {\n  //  console.log('currentObserver set')\n    registerObserver(target, key)\n    if (isObject) {\n      return observable || toObservable(result)\n    }\n  }\n\n\n  return observable || result\n}\n\n\nfunction set (target, key, value, receiver) {\n\n  console.log('setting' ,key, target , value)\n  if (key === 'length' || value !== Reflect.get(target, key, receiver)) { //lenght to observe changes in arrays\n\n//  if (value !== Reflect.get(target, key, receiver)) {\n    console.log('setting introspect',key,value,target)\n    queueObserver(target, key)\n    queueObserver(target, enumerate)\n  }\n  if (typeof value === 'object' && value) {\n    value = value.$raw || value\n  }\n  return Reflect.set(target, key, value, receiver)\n\n}\n\nfunction registerObserver (target, key) {\n  console.log('regestring',key,target)\n  const observersForTarget = observers.get(target)  //volta um mapa que contem as chaves desse objeto\n  let observersForKey = observersForTarget.get(key)  //volta um set que contem os pares\n  if (!observersForKey) {\n    observersForKey = new Set()\n    observersForTarget.set(key, observersForKey)\n    console.log('seting new observer for target ',key,observersForKey)\n  }\n  if (!observersForKey.has(currentObserver)) {\n    observersForKey.add(currentObserver)\n    currentObserver.observedKeys.push(observersForKey)\n  }\n\n // currentObserver.observedKeys.push(observersForKey)\n  //observersForKey.add(currentObserver)\n}\n\n\nfunction queueObserver (target,key) {\n  console.log('queueObserver for',key,target)\n  const observersForKey = observers.get(target).get(key)\n  if (observersForKey) {\n //   console.log('observer for key found!',key)\n    observersForKey.forEach((observer)=>{\n      //imediateObservers.add()\n    //  if (!observer.imediate){\n        queuedObservers.add(observer)\n  //    } else {\n     //   console.log('running imediate')\n       // imediateObservers.add(observer)\n    //    runObserver(observer)\n  //    }\n\n\n    })\n  }\n\n\n  if (!queued) {\n\n     nextTick(runObservers)\n     queued = true\n  }\n}\n\nfunction runObservers () {\n  queuedObservers.forEach(runObserver)\n  queuedObservers.clear()\n  queued = false\n}\n\nfunction runObserver (observer,firstRun) {\n  console.log('runObserver',observer)\n  try {\n  // if (firstRun){\n      currentObserver = observer\n   // }\n     observer.fn.apply(observer.context, observer.args)\n  } finally {\n  //  if (firstRun){\n      currentObserver = undefined\n  //  }\n\n\n  }\n\n}\n\nfunction ownKeys (target) {  //uses in for in loops and  enumerate is just a simbol to tag enumeration\n  if (currentObserver) {\n    console.log ('-------------- target ownKeys', target)\n    registerObserver(target, enumerate)\n  } else {\n    console.log (' ELSE------------------ target ownKeys', target)\n  }\n  return Reflect.ownKeys(target)\n}\n\n\nfunction unobserveKey (observersForKey) {\n  observersForKey.delete(this)\n}\n\nfunction unobserve () {\n  if (this.fn) {\n    this.observedKeys.forEach(unobserveKey, this)\n    this.fn = this.context = this.args = this.observedKeys = undefined\n    queuedObservers.delete(this)\n  }\n}\n\nfunction deleteProperty (target, key) {\n  if (Reflect.has(target, key)) {\n    queueObserver(target, key)\n    queueObserver(target, enumerate)\n  }\n  return Reflect.deleteProperty(target, key)\n}\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/observerLight.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\",\"umd\":\"react\"}\n// module id = 1\n// module chunks = 0","\n\nvar React = require ('react')\n//var observer = require('../observer/observer')\nvar observer = require('../observer/observerLight')\nvar isObjectShallowModified = require ('./isShallow');\nvar toClass = require ('./toClass');\nvar hoistStatics = require('./hoist-non-react-statics');\n\n\n\nvar connect = (...params) => {\n//https://github.com/mobxjs/mobx-react/blob/master/src/inject.js\n  //Comp = toClass(Comp);\n\n  if (typeof params[0] === 'function'){\n    //console.log ('sem opcoes vamos colocar tudo em um objeto store ou vamos colocar tudo em props?')\n    var mode = 'noOptions'\n  } else{\n\n    if (!Array.isArray(params[0])){\n       throw new Error(\"Store options must be an array\");\n    }\n    var mode = 'withOptions'\n    var options = params[0]\n  }\n\n\n  var factory = function (Comp){\n    Comp = toClass(Comp);\n\n    class Enhancer extends Comp {\n\n      /* static contextTypes = {\n       proxyoStores: React.PropTypes.object\n       };*/\n\n      constructor(props,context){\n\n        //console.log('constructor');\n        super(...arguments);\n\n        this.obs = {};\n        if (context.proxyoStores){\n          this.obs = context.proxyoStores\n        }\n\n\n\n\n        //  console.log(context);\n        this._fn = this._fn.bind(this);\n        this._signal = null;\n        this._mounted = false;\n        this._renderResult = null;\n\n      }\n\n      _fn (){\n        this._renderResult = super.render()\n        if (this._mounted){\n          console.log('change detected on '+getDisplayName(Comp))\n          this.forceUpdate()\n        }\n      }\n\n      componentDidMount() {\n        // console.log('did mount')\n        this._mounted = true;\n        if (super.componentWillUnmount){\n          super.componentWillUnmount()\n        }\n      }\n\n      shouldComponentUpdate(nextProps,nextState) {\n        //return false\n       // delete this.props.store\n        //  console.log(this.props)\n        //  console.log(nextProps)\n        //  console.log(isObjectShallowModified(this.props, nextProps));\n        if (this.state !== nextState) {\n          return true;\n        }\n        return isObjectShallowModified(this.props, nextProps);\n\n      }\n\n      componentWillUnmount() {\n        //   console.log('willunmount')\n        if (super.componentWillUnmount){\n          super.componentWillUnmount()\n        }\n        this._mounted = false\n        if (this._signal) {\n          this._signal.unobserve();\n          //  console.log(\"signal released\")\n        }\n      }\n      render() {\n\n\n        console.log('rendering HOC for -> '+getDisplayName(Comp))\n\n\n\n        //this.props =  Object.assign({}, this.props, {store:obs})\n        switch(mode) {\n          case 'noOptions':\n            this.props = Object.assign({}, this.obs, this.props)\n            break\n          case 'withOptions':\n            var selection = {}\n            var tt = options.map((value) => {\n              if (value in this.obs) {\n                selection[value] = this.obs[value]\n              }\n            })\n            console.log('selection',selection);\n            this.props = Object.assign({}, selection, this.props)\n            break\n        }\n\n\n\n\n//     console.log('render called ->', Comp.name)\n        if (!this._mounted){\n          this._signal = observer.observe(this._fn,this);\n        }\n        return this._renderResult\n      }\n    };\n\n    function getDisplayName (Comp) {\n      return Comp.displayName ||\n          Comp.name || `Component`\n    }\n\n    Enhancer.displayName = `HOCProxyo(${getDisplayName(Comp)})`\n\n    Enhancer.contextTypes = {\n      proxyoStores: React.PropTypes.object\n    };\n\n    hoistStatics(Enhancer,Comp)\n\n    return Enhancer\n  }\n\n\n  if (typeof params[0] === 'function'){\n    return factory(params[0])\n  }\n  return factory\n  /*if (params.length === 0){\n    //factory\n    console.log('no params?')\n    console.log(arguments)\n    return factory(arguments[5])\n  } else {\n    return factory\n  }\n\n*/\n\n}\n\n\n\nmodule.exports = connect\n//export default connect2\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/connect.js\n// module id = 2\n// module chunks = 0","\nvar React = require('react')\n\nconst specialReactKeys = {children: true, key: true, ref: true};\n\n\n\nclass Provider extends React.Component {\n\n/*  static contextTypes = {proxyoStores: React.PropTypes.object};\n\n  static childContextTypes = {proxyoStores: React.PropTypes.object.isRequired};*/\n\n  render() {\n    return React.Children.only(this.props.children);\n  }\n\n  getChildContext() {\n  //  console.log(this.props);\n   // const stores = {};\n    // inherit stores\n /*   const baseStores = this.context.proxyoStores;\n    if (baseStores)\n      for (let key in baseStores) {\n        stores[key] = baseStores[key];\n      }\n    // add own stores\n    for (let key in this.props)\n      stores[key] = this.props[key];\n    console.log(stores);*/\n    return {proxyoStores: this.props.proxyoStores};\n  }\n\n}\n\nProvider.contextTypes = {proxyoStores: React.PropTypes.object};\nProvider.childContextTypes = {proxyoStores: React.PropTypes.object.isRequired};\n\nmodule.exports = Provider\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/provider.js\n// module id = 3\n// module chunks = 0","/*var observable = require('../observer/observer').observable\n var interceptMap = require('../observer/observer').interceptMap\n var observer = require('../observer/observer')*/\nvar observable = require('../observer/observerLight').observable\nvar observer = require('../observer/observerLight')\n\nvar computedResult = new Set();\n\nvar intercept = function(target,method,property,interceptor){\n  interceptMap.set(target,[method,property,interceptor])\n}\n\nfunction action (...params){\n\n  var originalFn\n  var fn = function(...args){\n    var context = observer.proxies.get(this)\n    originalFn.apply(context||this,arguments)\n  }\n\n  var wraper = function (target,key,descriptor) {\n    originalFn = descriptor.value\n    descriptor.value = fn\n  }\n  //determinar o estilo usado @anotation ou function() se userFn existe eh function senao vai ser uma anotation\n  var userFn = (typeof params[0] === 'function') ? params[0] : null\n  if (!userFn){\n    userFn = ((typeof params[0] === 'string') && (typeof params[1] === 'function')) ? params[1] : null\n  }\n  if (userFn) {    //fazer o certo para functions()\n    originalFn = userFn\n    return fn;\n  }\n  else { //fazer o certo para actions\n    return (typeof params[0] === 'object') ? wraper(...params) : wraper\n  }\n\n}\n\n\nfunction computed (...params){\n\n  console.log(params)\n\n  var target = params[0]\n  var key = params[1]\n  var descriptor = params[2]\n\n  var originalGet = descriptor.get\n  var result\n\n  var wraper = function () {\n    console.log('inside wrapper')\n    result = originalGet.apply(this)\n    console.log('wrapper result ===============',result)\n  }\n  var signal = null\n\n  descriptor.get = function(){\n    console.log('inside get ')\n\n    if (!signal){\n      console.log(this)\n      //var ctx = observer.proxies.get(this)\n      console.log('NO SIGNAL')\n      //wraper.apply(this,arguments)\n    //  Promise.resolve().then(()=>{\n\n      signal = observer.observe(wraper,this)\n   //   })\n     /* setTimeout(()=>{\n        signal = observer.observe(wraper,this,arguments)\n      },0)*/\n\n\n      console.log(result)\n    }\n    console.log('RESSSSSSSSSSSSULT',result)\n    return result\n  }\n\n  //descriptor.get.bind(target)\n\n\n\n\n\n  /*var originalFn\n   var fn = function(...args){\n   var context = observer.proxies.get(this)\n   originalFn.apply(context||this,arguments)\n   }\n\n   var wraper = function (target,key,descriptor) {\n   originalFn = descriptor.value\n   descriptor.value = fn\n   }\n   //determinar o estilo usado @anotation ou function() se userFn existe eh function senao vai ser uma anotation\n   var userFn = (typeof params[0] === 'function') ? params[0] : null\n   if (!userFn){\n   userFn = ((typeof params[0] === 'string') && (typeof params[1] === 'function')) ? params[1] : null\n   }\n   if (userFn) {    //fazer o certo para functions()\n   originalFn = userFn\n   return fn;\n   }\n   else { //fazer o certo para actions\n   return (typeof params[0] === 'object') ? wraper(...params) : wraper\n   }*/\n\n}\n\n\n/*\n function Action(name,fn){\n return function(...args){\n var context = observer.proxies.get(this)\n return fn.apply(context||this,arguments)\n }\n }\n */\n\nvar state = observable({})\n\nvar replaceState = (userState)=> {\n  Object.keys(state).map((key)=>{\n    delete state[key]\n  })\n  Object.assign(state,userState)\n  return state\n}\n\n\n\nmodule.exports = {\n  intercept,\n  computed,\n  replaceState,\n  state,\n  action\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/proxyo.js\n// module id = 4\n// module chunks = 0","'use strict'\n\nconst native = Map.prototype\nconst masterKey = Symbol('Map master key')\n\nconst getters = ['has', 'get']\nconst iterators = ['forEach', 'keys', 'values', 'entries', Symbol.iterator]\nconst all = ['set', 'delete', 'clear'].concat(getters, iterators)\n\nmodule.exports = function shim (target, registerObserver, queueObservers) {\n  target.$raw = {}\n\n  for (let method of all) {\n    target.$raw[method] = function () {\n      native[method].apply(target, arguments)\n    }\n  }\n\n  for (let getter of getters) {\n    target[getter] = function (key) {\n      registerObserver(this, key)\n      return native[getter].apply(this, arguments)\n    }\n  }\n\n  for (let iterator of iterators) {\n    target[iterator] = function () {\n      registerObserver(this, masterKey)\n      return native[iterator].apply(this, arguments)\n    }\n  }\n\n  target.set = function (key, value) {\n    if (this.get(key) !== value) {\n      queueObservers(this, key)\n      queueObservers(this, masterKey)\n    }\n    return native.set.apply(this, arguments)\n  }\n\n  target.delete = function (key) {\n    if (this.has(key)) {\n      queueObservers(this, key)\n      queueObservers(this, masterKey)\n    }\n    return native.delete.apply(this, arguments)\n  }\n\n  target.clear = function () {\n    if (this.size) {\n      queueObservers(this, masterKey)\n    }\n    return native.clear.apply(this, arguments)\n  }\n\n  return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/Map.js\n// module id = 5\n// module chunks = 0","'use strict'\n\nconst native = Set.prototype\nconst masterValue = Symbol('Set master value')\n\nconst getters = ['has']\nconst iterators = ['forEach', 'keys', 'values', 'entries', Symbol.iterator]\nconst all = ['add', 'delete', 'clear'].concat(getters, iterators)\n\nmodule.exports = function shim (target, registerObserver, queueObservers) {\n  target.$raw = {}\n\n  for (let method of all) {\n    target.$raw[method] = function () {\n      native[method].apply(target, arguments)\n    }\n  }\n\n  for (let getter of getters) {\n    target[getter] = function (value) {\n      registerObserver(this, value)\n      return native[getter].apply(this, arguments)\n    }\n  }\n\n  for (let iterator of iterators) {\n    target[iterator] = function () {\n      registerObserver(this, masterValue)\n      return native[iterator].apply(this, arguments)\n    }\n  }\n\n  target.add = function (value) {\n    if (!this.has(value)) {\n      queueObservers(this, value)\n      queueObservers(this, masterValue)\n    }\n    return native.add.apply(this, arguments)\n  }\n\n  target.delete = function (value) {\n    if (this.has(value)) {\n      queueObservers(this, value)\n      queueObservers(this, masterValue)\n    }\n    return native.delete.apply(this, arguments)\n  }\n\n  target.clear = function () {\n    if (this.size) {\n      queueObservers(this, masterValue)\n    }\n    return native.clear.apply(this, arguments)\n  }\n\n  return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/Set.js\n// module id = 6\n// module chunks = 0","'use strict'\n\nconst native = WeakMap.prototype\n\nconst getters = ['has', 'get']\nconst all = ['set', 'delete'].concat(getters)\n\nmodule.exports = function shim (target, registerObserver, queueObservers) {\n  target.$raw = {}\n\n  for (let method of all) {\n    target.$raw[method] = function () {\n      native[method].apply(target, arguments)\n    }\n  }\n\n  for (let getter of getters) {\n    target[getter] = function (key) {\n      registerObserver(this, key)\n      return native[getter].apply(this, arguments)\n    }\n  }\n\n  target.set = function (key, value) {\n    if (this.get(key) !== value) {\n      queueObservers(this, key)\n    }\n    return native.set.apply(this, arguments)\n  }\n\n  target.delete = function (key) {\n    if (this.has(key)) {\n      queueObservers(this, key)\n    }\n    return native.delete.apply(this, arguments)\n  }\n\n  return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/WeakMap.js\n// module id = 7\n// module chunks = 0","'use strict'\n\nconst native = WeakSet.prototype\n\nconst getters = ['has']\nconst all = ['add', 'delete'].concat(getters)\n\nmodule.exports = function shim (target, registerObserver, queueObservers) {\n  target.$raw = {}\n\n  for (let method of all) {\n    target.$raw[method] = function () {\n      native[method].apply(target, arguments)\n    }\n  }\n\n  for (let getter of getters) {\n    target[getter] = function (value) {\n      registerObserver(this, value)\n      return native[getter].apply(this, arguments)\n    }\n  }\n\n  target.add = function (value) {\n    if (!this.has(value)) {\n      queueObservers(this, value)\n    }\n    return native.add.apply(this, arguments)\n  }\n\n  target.delete = function (value) {\n    if (this.has(value)) {\n      queueObservers(this, value)\n    }\n    return native.delete.apply(this, arguments)\n  }\n\n  return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/WeakSet.js\n// module id = 8\n// module chunks = 0","'use strict'\n\nconst MapShim = require('./Map')\nconst SetShim = require('./Set')\nconst WeakMapShim = require('./WeakMap')\nconst WeakSetShim = require('./WeakSet')\n\n\nmodule.exports = new Map([\n  [Map, MapShim],\n  [Set, SetShim],\n  [WeakMap, WeakMapShim],\n  [WeakSet, WeakSetShim],\n  [Date, true],\n  [RegExp, true]\n])\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/builtIns/index.js\n// module id = 9\n// module chunks = 0","'use strict'\n//https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\nlet promise = Promise.resolve()\nlet mutateWithTask\nlet currTask\n\nmodule.exports = function nextTick (task) {\n  currTask = task\n  if (mutateWithTask) {\n    mutateWithTask()\n  } else {\n    promise = promise.then(task)\n  }\n}\n\nif (typeof MutationObserver !== 'undefined') {\n  let counter = 0\n  const observer = new MutationObserver(onTask)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {characterData: true})\n\n  mutateWithTask = function mutateWithTask () {\n    counter = (counter + 1) % 2\n    textNode.textContent = counter\n  }\n}\n\nfunction onTask () {\n  if (currTask) {\n    currTask()\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/nextTick.js\n// module id = 10\n// module chunks = 0","'use strict'\n\nconst wellKnowSymbols = new Set()\n\nfor (let key of Object.getOwnPropertyNames(Symbol)) {\n  const value = Symbol[key]\n  if (typeof value === 'symbol') {\n    wellKnowSymbols.add(value)\n  }\n}\n\nmodule.exports = wellKnowSymbols\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/observer/wellKnownSymbols.js\n// module id = 11\n// module chunks = 0","var REACT_STATICS = {\n  childContextTypes: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\n\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  arguments: true,\n  arity: true\n};\n\nvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\nmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n  if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n    var keys = Object.getOwnPropertyNames(sourceComponent);\n\n    /* istanbul ignore else */\n    if (isGetOwnPropertySymbolsAvailable) {\n      keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n    }\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n        try {\n          targetComponent[keys[i]] = sourceComponent[keys[i]];\n        } catch (error) {\n\n        }\n      }\n    }\n  }\n\n  return targetComponent;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/hoist-non-react-statics.js\n// module id = 12\n// module chunks = 0","function isObjectShallowModified(prev, next) {\n  if (null == prev || null == next || typeof prev !== \"object\" || typeof next !== \"object\") {\n    return prev !== next;\n  }\n  const keys = Object.keys(prev);\n  if (keys.length !== Object.keys(next).length) {\n    return true;\n  }\n  let key;\n  for (let i = keys.length - 1; i >= 0, key = keys[i]; i--) {\n    if (next[key] !== prev[key]) {\n      return true;\n    }\n  }\n  return false;\n}\nmodule.exports = isObjectShallowModified\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/isShallow.js\n// module id = 13\n// module chunks = 0","var React = require('react')\n\nconst getDisplayName = Component => {\n  if (typeof Component === 'string') {\n    return Component\n  }\n\n  if (!Component) {\n    return undefined\n  }\n\n  return Component.displayName || Component.name || 'Component'\n}\n\nconst isClassComponent = Component => Boolean(\n    Component &&\n    Component.prototype &&\n    typeof Component.prototype.isReactComponent === 'object'\n)\n\n\n\nconst toClass = baseComponent => {\n  if (isClassComponent(baseComponent)) {\n    return baseComponent\n  }\n\n  class ToClass extends React.Component {\n    render() {\n      if (typeof baseComponent === 'string') {\n        return React.createElement(baseComponent, this.props)\n      }\n      return baseComponent(this.props, this.context)\n    }\n  }\n\n  ToClass.displayName = getDisplayName(baseComponent)\n  ToClass.propTypes = baseComponent.propTypes\n  ToClass.contextTypes = baseComponent.contextTypes\n  ToClass.defaultProps = baseComponent.defaultProps\n\n  return ToClass\n}\n\nmodule.exports = toClass\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/proxyo/toClass.js\n// module id = 14\n// module chunks = 0","\n/*\nimport observer from './observer/observer'\nimport {CreateState,globalState, globalActions}  from './proxyo/createState'\nexport {CreateState,globalState,\n  globalActions,observer}\n*/\n\n/*\nvar observer = require('./observer/observer');\nvar observerLight = require('./observer/observerLight');\nvar proxyo = require('./proxyo/proxyo');*/\nvar observer = require('./observer/observerLight');\nvar observerLight = require('./observer/observerLight');\nvar proxyo = require('./proxyo/proxyo');\n\n\nmodule.exports = {\n  observe:observer.observe,\n  observable:observer.observable,\n  observerLight:observerLight,\n  isObservable:observer.isObservable,\n  observer:observer,\n  action:proxyo.action,\n  computed:proxyo.computed,\n  replaceState:proxyo.replaceState,\n  state:proxyo.state,\n  intercept:proxyo.intercept,\n  connect: require('./proxyo/connect'),\n  Provider: require('./proxyo/provider'),\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 15\n// module chunks = 0"],"sourceRoot":""}